<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/png" href="NUTRIMANDALAS.png">
  <title>NUTRIMANDALAS ‚Äî GENERATOR</title>
  <style>
    :root{ --blue:#001aff; --row-h:52px; --pad:6px; --label-w:150px; }
@media (max-width: 480px){ :root{ --label-w:110px; } .controls label{ font-size:12px; } }
    *{box-sizing:border-box}
    body{margin:0;background:#fff;color:var(--blue);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Footlight MT Light",sans-serif;display:flex;flex-direction:column;align-items:center;gap:10px;padding:14px;text-align:center}
    .brand{display:flex;align-items:center;justify-content:space-between;gap:12px;width:100%;max-width:1180px}
    .brand h1{flex:1;margin:4px 0 6px;font-size:44px;letter-spacing:.3px}
    .brand img.logo{height:64px;width:auto;object-fit:contain}
    @media (max-width: 640px){
      .brand h1{font-size:32px}
      .brand img.logo{height:44px}
    }
    .topbar{display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap}
    .topbar input[type="file"]{padding:6px;background:#fff;border:2px solid var(--blue);border-radius:10px}
    button{padding:4px 8px;background:var(--blue);color:#fff;border:none;border-radius:10px;cursor:pointer;font-family:inherit;box-shadow:0 0 10px rgba(0,26,255,.45);font-size:12px}
    button:hover{opacity:.97;filter:brightness(1.03)}
    .controls{display:grid;grid-template-columns:repeat(4,minmax(180px,1fr));gap:8px;align-items:start;justify-content:center;max-width:1180px;width:100%}
    @media (max-width: 1100px){ .controls{grid-template-columns:repeat(3,minmax(180px,1fr));} }
    @media (max-width: 820px){ .controls{grid-template-columns:repeat(2,minmax(180px,1fr));} }
    @media (max-width: 520px){ .controls{grid-template-columns:1fr;} }
    .controls .row{display:grid;grid-template-columns:var(--label-w) 1fr;gap:8px;align-items:center;background:#f7f9ff;border:2px solid var(--blue);border-radius:10px;padding:var(--pad);min-height:var(--row-h);box-shadow:0 0 6px rgba(0,26,255,.22)}
    .controls label{justify-self:start;font-size:13px;line-height:1.05}
    .controls .right{display:flex;gap:6px;align-items:center}
    .controls input[type="range"], .controls select{width:100%; height:22px; accent-color: var(--blue); font-size:12px}
    input[type="range"]{height:24px}
    input[type="range"]::-webkit-slider-runnable-track{height:6px;background:linear-gradient(90deg,#cfe0ff,#86a8ff);border-radius:8px}
    input[type="range"]::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--blue);margin-top:-4px;box-shadow:0 0 0 2px #fff inset, 0 0 6px rgba(0,26,255,.7)}
    input[type="range"]::-moz-range-track{height:6px;background:linear-gradient(90deg,#cfe0ff,#86a8ff);border-radius:8px}
    input[type="range"]::-moz-range-thumb{width:14px;height:14px;border:none;border-radius:50%;background:var(--blue);box-shadow:0 0 0 2px #fff inset, 0 0 6px rgba(0,26,255,.7)}
    .val{font-variant-numeric:tabular-nums;border:2px solid var(--blue);border-radius:10px;padding:1px 6px;min-width:52px;text-align:center;color:var(--blue);background:#fff;font-size:11px}
    .stage{position:relative;display:inline-block;padding-right:380px}
@media (max-width: 820px){ .stage{ padding-right:0; } }
    canvas{border:2px solid var(--blue);border-radius:12px;width:100%;max-width:640px;height:auto;background:#fff;box-shadow:0 0 10px rgba(0,26,255,.18)} canvas{touch-action:none;}
    .overlay{position:absolute;z-index:5;display:none}
    .overlay.show{display:flex}
    .overlay.side{top:50%;right:8px;transform:translateY(-50%);flex-direction:column}
    .overlay.card{background:#f7f9ff;border:2px solid var(--blue);border-radius:12px;padding:10px;gap:8px;align-items:center;justify-content:center;box-shadow:0 10px 18px rgba(0,26,255,.18);width:90vw; max-width:320px;max-height:85vh;overflow:auto}
    #creditsOverlay{ font-size:12px; line-height:1.25; text-align:left }
    #creditsOverlay p{ margin:.3em 0 }
    .palette{display:flex;gap:6px;flex-wrap:wrap;justify-content:center}
    .swatch{width:20px;height:20px;border-radius:50%;border:2px solid var(--blue);background:var(--c);cursor:pointer}
    #info{white-space:normal;max-width:980px;margin-top:6px}
  
/* ===== MOBILE FIXES ===== */
body {
  overscroll-behavior: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}
canvas {
  touch-action: none;
}
@media (max-width: 900px){
  .stage { padding-right: 0 !important; }
}
@media (max-width: 480px){
  button { font-size: 16px !important; padding: 10px 16px !important; }
}


/* === Patch m√≥vil: gestos nativos por defecto === */
canvas { touch-action: auto; }
.touch-block { touch-action: none; }
</style>
</head>
<body>

  <div class="brand">
    <img class="logo" src="NUTRIMANDALAS.png" alt="NUTRIMANDALAS logo (left)">
    <h1>NUTRIMANDALAS ‚Äî GENERATOR</h1>
    <img class="logo" src="ibima.png" alt="IBIMA Plataforma BIONAND logo (right)">
  </div>

  <div class="topbar">
    <button id="langEs" title="Espa√±ol">ES</button>
    <button id="langEn" title="English">EN</button>
    <input id="file" type="file" accept="image/*" style="display:none" />
    <button id="fileBtn">üìÅ Select file</button><span id="fileName" style="margin-left:8px">No file chosen</span>
    <button id="paintToggle" aria-pressed="false">üîÜ Color</button>
    <button id="mosaicToggle" aria-pressed="true" title="Toggle mosaic">üî•</button>
    <button id="lanternToggle" aria-pressed="false" title="Mandala √∫nico centrado">üèÆ</button>
    <button id="panToggle" aria-pressed="false" title="Pan mosaic">üíÉüèΩ</button>
    <button id="download">‚¨áÔ∏è Download</button>
    <button id="wave" aria-pressed="false">üåä Credits</button>
  </div>

  <div class="controls">
    <div class="row"><label for="imgScale">Image scale</label><div class="right"><span class="val" id="imgScaleVal">100%</span><input id="imgScale" type="range" min="10" max="600" step="1" value="100"></div></div>
    <div class="row"><label for="tile">Tile size</label><div class="right"><span class="val" id="tileVal">180 px</span><input id="tile" type="range" min="60" max="800" step="10" value="180"></div></div>
    <div class="row"><label for="borderWidth">Outline width</label><div class="right"><span class="val" id="borderWidthVal">6 px</span><input id="borderWidth" type="range" min="1" max="20" step="1" value="6"></div></div>
    <div class="row"><label for="stroke">Stroke width</label><div class="right"><span class="val" id="strokeVal">1.8</span><input id="stroke" type="range" min="0.5" max="5" step="0.1" value="1.8"></div></div>

    <div class="row"><label for="dilate">Edge closing</label><div class="right"><span class="val" id="dilateVal">6 px</span><input id="dilate" type="range" min="0" max="20" step="1" value="6"></div></div>
    <div class="row"><label for="blur">Pre-smoothing</label><div class="right"><span class="val" id="blurVal">2 px</span><input id="blur" type="range" min="0" max="8" step="1" value="2"></div></div>
    <div class="row"><label for="edgeThr">Edge sensitivity</label><div class="right"><span class="val" id="edgeThrVal">35</span><input id="edgeThr" type="range" min="10" max="120" step="1" value="35"></div></div>
    <div class="row"><label for="thrFixed">Fixed threshold</label><div class="right"><span class="val" id="thrFixedVal">200</span><input id="thrFixed" type="range" min="0" max="255" step="1" value="200"></div></div>

    <div class="row"><label for="rings">Rings</label><div class="right"><span class="val" id="ringsVal">10</span><input id="rings" type="range" min="3" max="32" step="1" value="10"></div></div>
    <div class="row"><label for="spokes">Spokes</label><div class="right"><span class="val" id="spokesVal">20</span><input id="spokes" type="range" min="6" max="64" step="1" value="20"></div></div>
    <div class="row"><label for="style">Motif shape</label><div class="right"><select id="style">
      <option value="ellipse" selected>Ellipses (petals)</option>
      <option value="star">Star</option>
      <option value="tri">Triangles</option>
      <option value="hex">Hexagons</option>
      <option value="square">Squares/diamonds</option>
      <option value="flower">Flower</option>
      <option value="spiral">Spiral</option>
      <option value="wave">Waves</option>
      <option value="grid">Grid</option>
      <option value="none">Lines & rings only</option>
    </select></div></div>

    <div class="row"><label for="method">Mask method</label><div class="right"><select id="method">
      <option value="auto" selected>Automatic (Otsu if needed)</option>
      <option value="edges">Edges only</option>
      <option value="fixed">Fixed threshold</option>
    </select></div></div>
    <div class="row"><label for="invertSel" id="invertLabel">Mask</label><div class="right"><select id="invertSel"><option value="inside">Keep inside</option><option value="outside">Keep outside</option></select></div></div>

    <div class="row"><label for="exportScale">Export size</label><div class="right"><select id="exportScale">
      <option value="1">1√ó (1200√ó1200)</option>
      <option value="2">2√ó (2400√ó2400)</option>
      <option value="3">3√ó (3600√ó3600)</option>
      <option value="4">4√ó (4800√ó4800)</option>
    </select></div></div>
    <div class="row"><label for="format">Format</label><div class="right"><select id="format">
      <option value="png" selected>PNG</option>
      <option value="jpeg">JPEG</option>
      <option value="tiff">TIFF</option>
      <option value="pdf">PDF</option>
    </select></div></div>
    <div class="row"><label for="bgMode" id="bgLabel">Background</label><div class="right"><select id="bgMode"><option value="transparent" selected>Transparent</option><option value="white">White</option><option value="inverted">Inverted</option></select></div></div>
  </div>

  <div class="stage" id="stage">
    <div id="paintOverlay" class="overlay side card">
      <div class="palette" id="palette">
        <button class="swatch" data-c="#000000" style="--c:#000000" title="Black"></button>
        <button class="swatch" data-c="#ff0000" style="--c:#ff0000" title="Red"></button>
        <button class="swatch" data-c="#00a651" style="--c:#00a651" title="Green"></button>
        <button class="swatch" data-c="#0a57ff" style="--c:#0a57ff" title="Blue"></button>
        <button class="swatch" data-c="#ff9900" style="--c:#ff9900" title="Orange"></button>
        <button class="swatch" data-c="#ffd400" style="--c:#ffd400" title="Yellow"></button>
        <button class="swatch" data-c="#9b59b6" style="--c:#9b59b6" title="Purple"></button>
        <button class="swatch" data-c="#ff66cc" style="--c:#ff66cc" title="Pink"></button>
        <button class="swatch" data-c="#FFB6C1" style="--c:#FFB6C1" title="Light Pink"></button>
        <button class="swatch" data-c="#ffffff" style="--c:#ffffff" title="White"></button>
        <button class="swatch" data-c="#808080" style="--c:#808080" title="Gray"></button>
        <button class="swatch" data-c="#D4AF37" style="--c:#D4AF37" title="Gold"></button>
        <button class="swatch" data-c="#800020" style="--c:#800020" title="Wine red"></button>
        <button class="swatch" data-c="#8B4513" style="--c:#8B4513" title="Brown"></button>
        <button class="swatch" data-c="#90EE90" style="--c:#90EE90" title="Light green"></button>
        <button class="swatch" data-c="#ADD8E6" style="--c:#ADD8E6" title="Light blue"></button>
        <button class="swatch" data-c="#00CED1" style="--c:#00CED1" title="Turquoise"></button>
        <button class="swatch" data-c="#F5F5DC" style="--c:#F5F5DC" title="Beige"></button>
      </div>
      <button id="bucketTool" aria-pressed="true">ü™£ Fill</button>
      <button id="brushTool" aria-pressed="false">üñåÔ∏è Brush</button>
      <button id="eraser" aria-pressed="false">üßΩ Erase</button>
      <div class="row" style="margin-top:8px;display:flex;gap:8px;align-items:center;justify-content:center">
        <label for="brushSize" id="brushSizeLabel">Brush size</label>
        <input id="brushSize" type="range" min="1" max="80" value="20" style="width:120px">
        <span id="brushSizeVal">20 px</span>
      </div>
      <button id="clearPaint">üóëÔ∏è Clear</button>
    </div>

    <canvas id="c" width="1200" height="1200" aria-label="Canvas"></canvas>

    <div id="creditsOverlay" class="overlay side card" style="top:16px; right:8px; transform:none;"></div>
  </div>

  <div id="info"></div>

  <script>
  (function(){
    const $=id=>document.getElementById(id);
    const fileInput=$('file');
    const fileBtn=$('fileBtn');
    const fileName=$('fileName');
    const canvas=$('c');
    const ctx=canvas.getContext('2d');
    const downloadBtn=$('download');
    const waveBtn=$('wave');
    const paintToggle=$('paintToggle');
    const mosaicToggle=$('mosaicToggle');
    const panToggle=$('panToggle');
    const paintOverlay=$('paintOverlay');
    const creditsOverlay=$('creditsOverlay');
    const palette=$('palette');
    const bucketBtn=$('bucketTool');
    const brushBtn=$('brushTool');
    const brushSizeEl=$('brushSize');
    const brushSizeVal=$('brushSizeVal');
    const brushSizeLabel=$('brushSizeLabel');
    const eraserBtn=$('eraser');
    const clearPaintBtn=$('clearPaint');
    const infoDiv=$('info');
    const bgMode=$('bgMode');

    const blurEl=$('blur'), blurVal=$('blurVal');
    const edgeThrEl=$('edgeThr'), edgeThrVal=$('edgeThrVal');
    const dilateEl=$('dilate'), dilateVal=$('dilateVal');
    const borderWidthEl=$('borderWidth'), borderWidthVal=$('borderWidthVal');
    const methodEl=$('method');
    const thrFixedEl=$('thrFixed'), thrFixedVal=$('thrFixedVal');
    const invertSel=$('invertSel');
    const imgScaleEl=$('imgScale'), imgScaleVal=$('imgScaleVal');
    const exportScaleEl=$('exportScale');
    const formatEl=$('format');
    const tileEl=$('tile'), tileVal=$('tileVal');
    const strokeEl=$('stroke'), strokeVal=$('strokeVal');
    const spokesEl=$('spokes'), spokesVal=$('spokesVal');
    const ringsEl=$('rings'), ringsVal=$('ringsVal');
    const styleEl=$('style');

    // ===== i18n =====
    let currentLang = 'en';
    const I18N = {
      en: {
        sel:'üìÅ Select file', none:'No file chosen', paint:'üîÜ Color', dl:'‚¨áÔ∏è Download', cred:'üåä Credits',
        bg:'Background', bgTransparent:'Transparent', bgWhite:'White', bgInverted:'Inverted',
        brush:'üñåÔ∏è Brush', brushSize:'Brush size', clear:'üóëÔ∏è Clear', fill:'ü™£ Fill', erase:'üßΩ Erase',
        imgScale:'Image scale', tile:'Tile size', outline:'Outline width', stroke:'Stroke width', close:'Edge closing', smooth:'Pre-smoothing', edge:'Edge sensitivity', thr:'Fixed threshold',
        rings:'Rings', spokes:'Spokes', motif:'Motif shape', maskMethod:'Mask method', invert:'Mask', exp:'Export size', fmt:'Format',
        auto:'Automatic (Otsu if needed)', edges:'Edges only', fixed:'Fixed threshold',
        shapes:['Ellipses (petals)','Star','Triangles','Hexagons','Squares/diamonds','Flower','Spiral','Waves','Grid','Lines & rings only'],
        invKeepIn:'Keep inside', invKeepOut:'Keep outside',
        mosaicTitleOn:'Toggle mosaic (on)', mosaicTitleOff:'Toggle mosaic (off)',
        panOn:'Pan mosaic (hand)', panOff:'Pan mosaic',
        alertLoad:'Load an image and generate the mandala first.',
        creditsHTML: `<div>
  <div><strong><u>NUTRIMANDALAS ‚Äî GENERATOR</u></strong></div>
  <p>This tool was created within the <strong>‚ÄúNUTRIMANDALA‚Äù Project</strong>, focused on fighting anxiety and its relationship with dietary habits and obesity.</p>
  <p><strong>Principal Investigators</strong><br>Daniel Hinojosa-Nogueira<br>Isabel Moreno-Indias</p>
  <p><strong>Team Members</strong><br>Cristina M¬™ D√≠az-Perdigones<br>Alba Subiri-Verdugo<br>Alba Rodr√≠guez-Mu√±oz<br>Mar√≠a Jos√© Garc√≠a-L√≥pez<br>Francisco J. Tinahones</p>
  <p><strong>Affiliations</strong><br>IBIMA - BIONAND<br>Clinical Management Unit of Endocrinology and Nutrition<br>Virgen de la Victoria University Hospital<br>M√°laga, Spain.</p>
  <p style="margin-top:8px">
    <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener license"><strong>NUTRIMANDALAS</strong> ¬© 2025 ‚Äî CC BY-NC 4.0</a>
    <img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" alt="CC" style="max-width:1em;max-height:1em;margin-left:.2em;">
    <img src="https://mirrors.creativecommons.org/presskit/icons/by.svg" alt="BY" style="max-width:1em;max-height:1em;margin-left:.2em;">
    <img src="https://mirrors.creativecommons.org/presskit/icons/nc.svg" alt="NC" style="max-width:1em;max-height:1em;margin-left:.2em;">
  </p>
</div>`
      },
      es: {
        sel:'üìÅ Seleccionar archivo', none:'Ning√∫n archivo seleccionado', paint:'üîÜ Colorear', dl:'‚¨áÔ∏è Descargar', cred:'üåä Cr√©ditos',
        bg:'Fondo', bgTransparent:'Transparente', bgWhite:'Blanco', bgInverted:'Invertido',
        brush:'üñåÔ∏è Pincel', brushSize:'Tama√±o del pincel', clear:'üóëÔ∏è Limpiar', fill:'ü™£ Relleno', erase:'üßΩ Borrar',
        imgScale:'Escala de la imagen', tile:'Tama√±o del mosaico', outline:'Grosor del contorno', stroke:'Grosor del trazo', close:'Cierre de borde', smooth:'Suavizado previo', edge:'Sensibilidad de borde', thr:'Umbral fijo',
        rings:'Anillos', spokes:'Radios', motif:'Forma de motivo', maskMethod:'M√©todo de m√°scara', invert:'M√°scara', exp:'Tama√±o de exportaci√≥n', fmt:'Formato',
        auto:'Autom√°tico (Otsu si es necesario)', edges:'Solo por bordes', fixed:'Umbral fijo',
        shapes:['Elipses (p√©talos)','Estrella','Tri√°ngulos','Hex√°gonos','Cuadrados/rombos','Flor','Espiral','Ondas','Rejilla','Solo l√≠neas y anillos'],
        invKeepIn:'Conservar interior', invKeepOut:'Conservar exterior',
        mosaicTitleOn:'Activar/Desactivar mosaico (activo)', mosaicTitleOff:'Activar/Desactivar mosaico (inactivo)',
        panOn:'Mover mosaico (mano)', panOff:'Mover mosaico',
        alertLoad:'Primero carga una imagen y genera el mandala.',
        creditsHTML: `<div>
  <div><strong><u>NUTRIMANDALAS ‚Äî GENERATOR</u></strong></div>
  <p>Esta herramienta se cre√≥ en el marco del<strong> ‚ÄúProyecto NUTRIMANDALA‚Äù</strong>, centrado en combatir la ansiedad y su relaci√≥n con los h√°bitos alimentarios y la obesidad.</p>
  <p><strong>Investigadores principales</strong><br>Daniel Hinojosa-Nogueira<br>Isabel Moreno-Indias</p>
  <p><strong>Miembros del equipo</strong><br>Cristina M¬™ D√≠az-Perdigones<br>Alba Subiri-Verdugo<br>Alba Rodr√≠guez-Mu√±oz<br>Mar√≠a Jos√© Garc√≠a-L√≥pez<br>Francisco J. Tinahones</p>
  <p><strong>Afiliaciones</strong><br>IBIMA - BIONAND<br>Unidad de Gesti√≥n Cl√≠nica de Endocrinolog√≠a y Nutrici√≥n<br>Hospital Universitario Virgen de la Victoria<br>M√°laga, Espa√±a.</p>
  <p style="margin-top:8px">
    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.es" target="_blank" rel="noopener license"><strong>NUTRIMANDALAS</strong> ¬© 2025 ‚Äî CC BY-NC 4.0</a>
    <img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" alt="CC" style="max-width:1em;max-height:1em;margin-left:.2em;">
    <img src="https://mirrors.creativecommons.org/presskit/icons/by.svg" alt="BY" style="max-width:1em;max-height:1em;margin-left:.2em;">
    <img src="https://mirrors.creativecommons.org/presskit/icons/nc.svg" alt="NC" style="max-width:1em;max-height:1em;margin-left:.2em;">
  </p>
</div>`
      }
    };

    function setLang(lang){
      currentLang = (lang==='es') ? 'es' : 'en';
      const L = I18N[currentLang];

      document.documentElement.lang = currentLang;
      fileBtn.textContent=L.sel;
      fileName.textContent=(fileInput.files && fileInput.files[0]) ? fileInput.files[0].name : L.none;
      paintToggle.textContent=L.paint;
      downloadBtn.textContent=L.dl;
      waveBtn.textContent=L.cred;

      bucketBtn.textContent=L.fill;
      brushBtn.textContent=L.brush;
      eraserBtn.textContent=L.erase;
      brushSizeLabel.textContent=L.brushSize;
      brushSizeVal.textContent=brushSizeEl.value + ' px';

      document.getElementById('bgLabel').textContent = L.bg;
      const bgSel=document.getElementById('bgMode');
      if(bgSel){ bgSel.options[0].text=L.bgTransparent; bgSel.options[1].text=L.bgWhite; if(bgSel.options[2]) bgSel.options[2].text=L.bgInverted; }

      document.querySelector('label[for="imgScale"]').textContent=L.imgScale;
      document.querySelector('label[for="tile"]').textContent=L.tile;
      document.querySelector('label[for="borderWidth"]').textContent=L.outline;
      document.querySelector('label[for="stroke"]').textContent=L.stroke;
      document.querySelector('label[for="dilate"]').textContent=L.close;
      document.querySelector('label[for="blur"]').textContent=L.smooth;
      document.querySelector('label[for="edgeThr"]').textContent=L.edge;
      document.querySelector('label[for="thrFixed"]').textContent=L.thr;
      document.querySelector('label[for="rings"]').textContent=L.rings;
      document.querySelector('label[for="spokes"]').textContent=L.spokes;
      document.querySelector('label[for="style"]').textContent=L.motif;
      document.querySelector('label[for="method"]').textContent=L.maskMethod;
      document.getElementById('invertLabel').textContent = L.invert;
      document.querySelector('label[for="exportScale"]').textContent=L.exp;
      document.querySelector('label[for="format"]').textContent=L.fmt;

      let methodSel=methodEl.options; methodSel[0].text=L.auto; methodSel[1].text=L.edges; methodSel[2].text=L.fixed;
      let shapesSel=styleEl.options; let arr=L.shapes; for(let j=0;j<shapesSel.length;j++) shapesSel[j].text=arr[j];

      invertSel.options[0].text=L.invKeepIn;
      invertSel.options[1].text=L.invKeepOut;

      mosaicToggle.title = mosaicVisible ? L.mosaicTitleOn : L.mosaicTitleOff;
      panToggle.title = panMode ? L.panOn : L.panOff;

      if(creditsOn){ creditsOverlay.innerHTML = L.creditsHTML; }
    }

    // ===== Estado de mosaico y movimiento =====
    let mosaicVisible = true;
    let panMode = false;
    let draggingPan = false;
    let panStart = null;
    let tileOffsetX = 0, tileOffsetY = 0;

    function setPanMode(on){
      panMode = !!on;
      panToggle.setAttribute('aria-pressed', panMode ? 'true' : 'false');
      panToggle.textContent = panMode ? 'üñêÔ∏è' : 'üíÉüèΩ';
      panToggle.title = I18N[currentLang][ panMode ? 'panOn' : 'panOff' ];
      updateCursor();
    }

    // ===== Utils =====
    function mod(a,b){ return ((a % b) + b) % b; }
    function fitDrawImageScaled(ctx, img, w, h, scalePct){
      const s=Math.max(0.05, scalePct/100); const iw=img.width*s, ih=img.height*s; const cx=(w-iw)/2, cy=(h-ih)/2; ctx.drawImage(img,cx,cy,iw,ih);
    }
    function gaussianKernel(size,sigma){ const r=(size-1)/2; const k=[]; let sum=0; for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){ const v=Math.exp(-(x*x+y*y)/(2*sigma*sigma)); k.push(v); sum+=v; } return k.map(v=>v/sum); }
    function convolveGray(src,w,h,k){ const out=new Float32Array(w*h); const ks=Math.sqrt(k.length)|0; const r=(ks-1)/2|0; const gray=(x,y)=>{ const xi=Math.min(w-1,Math.max(0,x)); const yi=Math.min(h-1,Math.max(0,y)); const i=(yi*w+xi)*4; return 0.2126*src[i]+0.7152*src[i+1]+0.0722*src[i+2]; }; for(let y=0;y<h;y++) for(let x=0;x<w;x++){ let acc=0,idx=0; for(let ky=-r;ky<=r;ky++) for(let kx=-r;kx<=r;kx++) acc+=gray(x+kx,y+ky)*k[idx++]; out[y*w+x]=acc; } return out; }
    function otsuThreshold(hist,total){ let sum=0; for(let i=0;i<256;i++) sum+=i*hist[i]; let sumB=0,wB=0,maxVar=0,thr=128; for(let t=0;t<256;t++){ wB+=hist[t]; if(wB===0) continue; const wF=total-wB; if(wF===0) break; sumB+=t*hist[t]; const mB=sumB/wB, mF=(sum-sumB)/wF; const between=wB*wF*(mB-mF)*(mB-mF); if(between>maxVar){ maxVar=between; thr=t; } } return thr; }

    // ===== Carga de imagen =====
    function loadBitmap(file){ return new Promise(async (resolve,reject)=>{
      const fail=(e)=>reject(e instanceof Error?e:new Error(String(e)));
      try{
        if('createImageBitmap' in window){
          const bmp=await createImageBitmap(file);
          const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height;
          c.getContext('2d').drawImage(bmp,0,0);
          const img=new Image();
          img.onload=()=>resolve(img); img.onerror=(e)=>fail(e); img.src=c.toDataURL('image/png'); return;
        }
      }catch(e){ console.warn('createImageBitmap failed',e); }
      try{
        const url=URL.createObjectURL(file);
        const img2=new Image();
        img2.onload=()=>{ URL.revokeObjectURL(url); resolve(img2); };
        img2.onerror=(e)=>{ URL.revokeObjectURL(url); fail(e); };
        img2.src=url;
      }catch(e){ fail(e); }
    }); }

    let imgEl=null, lastMask=null, lastBorder=null, guideData=null;

    function insideByThreshold(g, thr){ return (invertSel.value === 'inside') ? (g > thr) : !(g > thr); }

    // ===== M√°scara y borde =====
    function buildMask(){
      const w=canvas.width,h=canvas.height;
      const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h; const t=tmp.getContext('2d');
      t.clearRect(0,0,w,h);
      if(imgEl) fitDrawImageScaled(t,imgEl,w,h,parseInt(imgScaleEl.value,10));
      const src=t.getImageData(0,0,w,h), s=src.data;

      const blurPx=parseInt(blurEl.value,10);
      let gray=convolveGray(s,w,h,gaussianKernel(blurPx>0?(blurPx|1):1,Math.max(0.8,blurPx*0.6)));
      if(blurPx===0){
        gray=new Float32Array(w*h);
        for(let y=0;y<h;y++) for(let x=0;x<w;x++){
          const i=(y*w+x)*4;
          gray[y*w+x]=0.2126*s[i]+0.7152*s[i+1]+0.0722*s[i+2];
        }
      }

      const edgeThr=parseInt(edgeThrEl.value,10);
      const ed=new Uint8ClampedArray(w*h);
      const gAt=(x,y)=> gray[Math.min(h-1,Math.max(0,y))*w + Math.min(w-1,Math.max(0,x))];
      for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
        const gx=-gAt(x-1,y-1)-2*gAt(x-1,y)-gAt(x-1,y+1)+gAt(x+1,y-1)+2*gAt(x+1,y)+gAt(x+1,y+1);
        const gy=-gAt(x-1,y-1)-2*gAt(x,y-1)-gAt(x+1,y-1)+gAt(x-1,y+1)+2*gAt(x,y+1)+gAt(x+1,y+1);
        ed[y*w+x]=Math.hypot(gx,gy)>edgeThr?255:0;
      }

      const R=parseInt(dilateEl.value,10);
      const dil=new Uint8ClampedArray(w*h);
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        let hit=false;
        for(let yy=y-R;yy<=y+R && !hit;yy++){
          if(yy<0||yy>=h) continue;
          for(let xx=x-R;xx<=x+R;xx++){
            if(xx<0||xx>=w) continue;
            if(ed[yy*w+xx]){ hit=true; break; }
          }
        }
        dil[y*w+x]=hit?255:0;
      }

      const mask=document.createElement('canvas'); mask.width=w; mask.height=h; const mx=mask.getContext('2d');
      const out=mx.createImageData(w,h); const o=out.data;
      const method=methodEl.value;

      if(method==='fixed'){
        const thr=parseInt(thrFixedEl.value,10);
        for(let y=0;y<h;y++) for(let x=0;x<w;x++){
          const g=gAt(x,y);
          const inside=insideByThreshold(g,thr);
          const i=(y*w+x)*4; o[i+3]=inside?255:0;
        }
      } else {
        const outside=new Uint8Array(w*h), q=[];
        const push=(i)=>q.push(i);
        for(let x=0;x<w;x++){
          if(dil[x]===0){ outside[x]=1; push(x); }
          if(dil[(h-1)*w+x]===0){ outside[(h-1)*w+x]=1; push((h-1)*w+x); }
        }
        for(let y=0;y<h;y++){
          if(dil[y*w]===0){ outside[y*w]=1; push(y*w); }
          if(dil[y*w+w-1]===0){ outside[y*w+w-1]=1; push(y*w+w-1); }
        }
        while(q.length){
          const i=q.shift();
          const n=[i-1,i+1,i-w,i+w];
          for(const ni of n){
            if(ni<0||ni>=w*h) continue;
            if(outside[ni]) continue;
            if(dil[ni]===0){ outside[ni]=1; q.push(ni); }
          }
        }
        for(let i=0;i<w*h;i++){
          const a=(!outside[i] && dil[i]===0)?255:0;
          o[i*4+3]=a;
        }

        let count=0; for(let i=0;i<w*h;i++) if(o[i*4+3]) count++;
        if(method==='auto' && count<(w*h*0.002)){
          const hist=new Uint32Array(256); let total=0;
          for(let y=0;y<h;y++) for(let x=0;x<w;x++){ const g=gAt(x,y)|0; hist[g]++; total++; }
          let thr=otsuThreshold(hist,total);
          for(let y=0;y<h;y++) for(let x=0;x<w;x++){
            const gg=gAt(x,y);
            const inside=insideByThreshold(gg,thr);
            const i=(y*w+x)*4; o[i+3]=inside?255:0;
          }
        }
      }

      mx.putImageData(out,0,0);

      const border=document.createElement('canvas'); border.width=w; border.height=h; const bx=border.getContext('2d');
      const mid=mx.getImageData(0,0,w,h).data; const bd=bx.createImageData(w,h); const b=bd.data; const BW=parseInt(borderWidthEl.value,10);
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const i=(y*w+x)*4; if(mid[i+3]===0) continue; let near=false;
        for(let yy=y-BW;yy<=y+BW && !near;yy++){
          if(yy<0||yy>=h) continue;
          for(let xx=x-BW;xx<=x+BW;xx++){
            if(xx<0||xx>=w) continue;
            if(mid[(yy*w+xx)*4+3]===0){ near=true; break; }
          }
        }
        if(near){ b[i]=b[i+1]=b[i+2]=0; b[i+3]=255; }
      }
      bx.putImageData(bd,0,0);

      lastMask=mask; lastBorder=border;
      return {mask,border};
    }

    function makeMandalaTile(size){
      const spokes=parseInt(spokesEl.value,10), rings=parseInt(ringsEl.value,10);
      const stroke=parseFloat(strokeEl.value);
      const style=styleEl.value;
      const t=document.createElement('canvas'); t.width=t.height=size; const x=t.getContext('2d');
      x.translate(size/2,size/2);
      x.strokeStyle='#000';
      x.lineWidth=Math.max(0.5,size*0.004*stroke);
      for(let k=1;k<=rings;k++){ x.beginPath(); x.arc(0,0,(k/(rings+1))*(size*0.48),0,Math.PI*2); x.stroke(); }
      const a=(Math.PI*2)/spokes;
      for(let i=0;i<spokes;i++){
        x.save();
        x.rotate(i*a);
        x.beginPath(); x.moveTo(0,0); x.lineTo(size*0.48,0); x.stroke();
        for(let p=1;p<=rings;p++){
          const rr=(p/(rings+1))*(size*0.46);
          if(style==='ellipse'){ x.beginPath(); x.ellipse(rr,0,rr*0.20,rr*0.08,0,0,Math.PI*2); x.stroke(); }
          else if(style==='star'){ x.beginPath(); x.moveTo(rr-rr*0.12,0); x.lineTo(rr+rr*0.12,0); x.moveTo(rr,-rr*0.12); x.lineTo(rr,rr*0.12); x.stroke(); }
          else if(style==='tri'){ x.beginPath(); x.moveTo(rr,0); x.lineTo(rr-rr*0.12, rr*0.12); x.lineTo(rr-rr*0.12, -rr*0.12); x.closePath(); x.stroke(); }
          else if(style==='hex'){ x.beginPath(); for(let k=0;k<6;k++){ const ang=k*Math.PI/3; const px=rr*Math.cos(ang), py=rr*Math.sin(ang); if(k===0)x.moveTo(px,py); else x.lineTo(px,py);} x.closePath(); x.stroke(); }
          else if(style==='square'){ x.beginPath(); const s=rr*0.18; x.rect(rr-s,-s,s*2,s*2); x.stroke(); }
          else if(style==='flower'){ x.beginPath(); const petals=6; for(let k=0;k<petals;k++){ const ang=k*(2*Math.PI/petals); const px=rr*Math.cos(ang), py=rr*Math.sin(ang); x.moveTo(px,py); x.arc(px,py, rr*0.10, 0, Math.PI*2);} x.stroke(); }
          else if(style==='spiral'){ x.beginPath(); const turns=2; for(let t0=0;t0<=Math.PI*turns;t0+=0.1){ const rad=rr*(t0/(Math.PI*turns)); x.lineTo(rad,0); x.rotate(0.1); } x.stroke(); }
          else if(style==='wave'){ x.beginPath(); const L=rr*0.6,A=rr*0.08; for(let u=-L;u<=L;u+=rr*0.06){ const y=A*Math.sin((u+L)/rr*4*Math.PI); x.lineTo(rr+u,y);} x.stroke(); }
        }
        x.restore();
      }
      return t;
    }

    function fillPatternWithOffset(ctxTarget, pat, W, H, tileSize){
      ctxTarget.save();
      if (pat && pat.setTransform){
        const m=new DOMMatrix(); m.translateSelf(mod(tileOffsetX, tileSize), mod(tileOffsetY, tileSize));
        pat.setTransform(m);
        ctxTarget.fillStyle=pat;
        ctxTarget.fillRect(0,0,W,H);
      }else if(pat){
        const ox=mod(tileOffsetX, tileSize), oy=mod(tileOffsetY, tileSize);
        ctxTarget.translate(ox, oy);
        ctxTarget.fillStyle=pat;
        ctxTarget.fillRect(-ox,-oy,W,H);
      }
      ctxTarget.restore();
    }

    // ===== Pintado principal =====
    function paintTo(ctxTarget,W,H){
      const tileSize=parseInt(tileEl.value,10);
      const tile=makeMandalaTile(tileSize);
      const pat=ctxTarget.createPattern(tile,'repeat');

      // Fondo base (blanco) para composici√≥n; si est√° invertido se invierte al final al exportar y se simula con CSS
      ctxTarget.save();
      ctxTarget.fillStyle='#fff'; ctxTarget.fillRect(0,0,W,H);
      ctxTarget.restore();

      if(!imgEl){
        if(mosaicVisible && pat) fillPatternWithOffset(ctxTarget, pat, W, H, tileSize);
        const g=document.createElement('canvas'); g.width=W; g.height=H; const gx=g.getContext('2d');
        gx.fillStyle='#fff'; gx.fillRect(0,0,W,H);
        if(mosaicVisible && pat) fillPatternWithOffset(gx, pat, W, H, tileSize);
        // --- FIX: fondo blanco detr√°s de la gu√≠a (para evitar transparencias que bloqueen el Fill)
        (function(){
          var __ctx = gx;
          __ctx.save();
          __ctx.globalCompositeOperation = 'destination-over';
          __ctx.fillStyle = '#ffffff';
          var __c = __ctx.canvas;
          __ctx.fillRect(0, 0, __c.width, __c.height);
          __ctx.restore();
        })();
                guideData=gx.getImageData(0,0,W,H);
        if(paintLayer){ ctxTarget.drawImage(paintLayer,0,0,W,H); }
        return;
      }

      const b=buildMask();
      const mask=b.mask, border=b.border;

      if(mosaicVisible && pat){
        fillPatternWithOffset(ctxTarget, pat, W, H, tileSize);
        ctxTarget.save();
        if(invertSel.value==='outside'){ ctxTarget.globalCompositeOperation='destination-out'; }
        else { ctxTarget.globalCompositeOperation='destination-in'; }
        ctxTarget.drawImage(mask,0,0);
        ctxTarget.restore();
      }

      ctxTarget.drawImage(border,0,0);

      // Guide = patr√≥n recortado + borde
      const g=document.createElement('canvas'); g.width=W; g.height=H; const gx=g.getContext('2d');
      gx.fillStyle='#fff'; gx.fillRect(0,0,W,H);
      if(mosaicVisible && pat){
        fillPatternWithOffset(gx, pat, W, H, tileSize);
        if(invertSel.value==='outside'){ gx.globalCompositeOperation='destination-out'; } else { gx.globalCompositeOperation='destination-in'; }
        gx.drawImage(mask,0,0);
      }
      gx.drawImage(border,0,0);
      // --- FIX: fondo blanco detr√°s de la gu√≠a (para evitar transparencias que bloqueen el Fill)
      (function(){
        var __ctx = gx;
        __ctx.save();
        __ctx.globalCompositeOperation = 'destination-over';
        __ctx.fillStyle = '#ffffff';
        var __c = __ctx.canvas;
        __ctx.fillRect(0, 0, __c.width, __c.height);
        __ctx.restore();
      })();
            guideData=gx.getImageData(0,0,W,H);

      if(paintLayer){ ctxTarget.drawImage(paintLayer,0,0,W,H); }
    }

    function applyBgModeVisual(){
      if(!bgMode) return;
      const mode = bgMode.value;
      if(mode==='inverted'){
        canvas.style.filter='invert(1)';
        canvas.style.background='#fff';
      }else if(mode==='white'){
        canvas.style.filter='none';
        canvas.style.background='#fff';
      }else{
        canvas.style.filter='none';
        canvas.style.background='transparent';
      }
    }

    function render(){
      const W=canvas.width,H=canvas.height;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,W,H);
      try{ paintTo(ctx,W,H);}catch(e){ showErr('Error while generating mandala',e); }
      applyBgModeVisual();
    }

    // ===== Exportaci√≥n =====
    function makePDFfromRGB(rgbBytes,w,h){
      const te = new TextEncoder();
      const chunks = []; let size = 0; const offsets=[0];
      const add=(s)=>{ const b=te.encode(s); chunks.push(b); size+=b.length; };
      const addBin=(b)=>{ chunks.push(b); size+=b.length; };
      const mark=()=>{ offsets.push(size); };
      add('%PDF-1.4\n');
      mark(); add('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
      mark(); add('2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n');
      mark(); add(`3 0 obj
<< /Type /Page /Parent 2 0 R
/MediaBox [0 0 ${w} ${h}]
/Resources << /ProcSet [/PDF /ImageC] /XObject << /Im0 4 0 R >> >>
/Contents 5 0 R >>
endobj
`);
      mark(); add(`4 0 obj
<< /Type /XObject /Subtype /Image /Width ${w} /Height ${h} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Length ${rgbBytes.length} >>
stream
`);
      addBin(rgbBytes);
      add('\nendstream\nendobj\n');
      const content = `q
${w} 0 0 ${h} 0 0 cm
/Im0 Do
Q
`;
      mark(); add(`5 0 obj
<< /Length ${content.length} >>
stream
${content}endstream
endobj
`);
      const startxref=size;
      add('xref\n0 6\n');
      add('0000000000 65535 f \n');
      for(let i=1;i<=5;i++){ const off=String(offsets[i]).padStart(10,'0'); add(off+' 00000 n \n'); }
      add(`trailer
<< /Size 6 /Root 1 0 R >>
startxref
${startxref}
%%EOF`);
      return new Blob(chunks,{type:'application/pdf'});
    }

    function makeTIFFfromCanvas(can){
      const w=can.width,h=can.height; const x=can.getContext('2d');
      const img=x.getImageData(0,0,w,h).data;
      const pixels=new Uint8Array(w*h*3);
      for(let i=0,j=0;i<img.length;i+=4){ pixels[j++]=img[i]; pixels[j++]=img[i+1]; pixels[j++]=img[i+2]; }
      function u16(v){ return new Uint8Array([v&255,v>>8]); } function u32(v){ return new Uint8Array([v&255,(v>>8)&255,(v>>16)&255,(v>>24)&255]); }
      const header=new Uint8Array([0x49,0x49,42,0,8,0,0,0]); const ifdEntries=10; const outLen=8+ifdEntries*12+4+6;
      const out=new Uint8Array(outLen+pixels.length); out.set(header,0);
      out.set(u16(ifdEntries),8); let ofs=10;
      function writeEntry(tag,type,count,value){ out.set(u16(tag),ofs); out.set(u16(type),ofs+2); out.set(u32(count),ofs+4); out.set(u32(value),ofs+8); ofs+=12; }
      const bitsOffset=8+ifdEntries*12+4; const stripOffset=bitsOffset+6;
      writeEntry(256,4,1,w); writeEntry(257,4,1,h); writeEntry(258,3,3,bitsOffset); writeEntry(259,3,1,1); writeEntry(262,3,1,2); writeEntry(273,4,1,stripOffset); writeEntry(277,3,1,3); writeEntry(278,4,1,h); writeEntry(279,4,1,pixels.length); writeEntry(284,3,1,1);
      out.set(u32(0),ofs); out.set(new Uint8Array([8,0,8,0,8,0]),8+ifdEntries*12+4);
      out.set(pixels,stripOffset);
      return new Blob([out],{type:'image/tiff'});
    }

    $('download').addEventListener('click',function(){
      const mult=parseInt(exportScaleEl.value,10);
      const W=1200*mult, H=1200*mult;
      const off=document.createElement('canvas'); off.width=W; off.height=H;
      const ox=off.getContext('2d');
      const fmt=formatEl.value;
      const mode = (typeof bgMode!=='undefined' && bgMode) ? bgMode.value : 'transparent';

      // Pintamos lo que se ve (sin filtros CSS), y luego aplicamos la inversi√≥n en p√≠xel si procede
      ox.imageSmoothingEnabled = true;
      ox.imageSmoothingQuality = 'high';
      if(mode==='white' || fmt==='jpeg' || fmt==='pdf'){
        ox.fillStyle = (mode==='inverted') ? '#000' : '#fff';
        ox.fillRect(0,0,W,H);
      } else if(mode==='inverted'){
        ox.fillStyle = '#000';
        ox.fillRect(0,0,W,H);
      }
      ox.drawImage(canvas, 0, 0, W, H);

      if(mode==='inverted'){
        const imgData = ox.getImageData(0,0,W,H);
        const d = imgData.data;
        for(let i=0;i<d.length;i+=4){ d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; }
        ox.putImageData(imgData,0,0);
      }

      if(fmt==='png'){
        const url=off.toDataURL('image/png');
        const a=document.createElement('a'); a.download='nutrimandala.png'; a.href=url; if(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)){
          window.open(a.href, '_blank');
        } else {
          a.click();
        }
      } else if(fmt==='jpeg'){
        const url=off.toDataURL('image/jpeg',0.98);
        const a=document.createElement('a'); a.download='nutrimandala.jpg'; a.href=url; if(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)){
          window.open(a.href, '_blank');
        } else {
          a.click();
        }
      } else if(fmt==='pdf'){
        const imgData = ox.getImageData(0,0,W,H).data;
        const rgb = new Uint8Array(W*H*3);
        for(let i=0,j=0;i<imgData.length;i+=4){ rgb[j++]=imgData[i]; rgb[j++]=imgData[i+1]; rgb[j++]=imgData[i+2]; }
        const blob=makePDFfromRGB(rgb,W,H);
        const a=document.createElement('a'); a.download='nutrimandala.pdf'; const url=URL.createObjectURL(blob); a.href=url; if(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)){
          window.open(a.href, '_blank');
        } else {
          a.click();
        } setTimeout(()=>URL.revokeObjectURL(url),2000);
      } else if(fmt==='tiff'){
        const blob=makeTIFFfromCanvas(off);
        const a=document.createElement('a'); a.download='nutrimandala.tif'; const url=URL.createObjectURL(blob); a.href=url; if(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)){
          window.open(a.href, '_blank');
        } else {
          a.click();
        } setTimeout(()=>URL.revokeObjectURL(url),2000);
      }
    });

    // ===== Cr√©ditos =====
    let creditsOn=false;
    waveBtn.addEventListener('click',function(){
      creditsOn=!creditsOn;
      waveBtn.setAttribute('aria-pressed', creditsOn?'true':'false');
      creditsOverlay.classList.toggle('show', creditsOn);
      if(creditsOn){ creditsOverlay.innerHTML = I18N[currentLang].creditsHTML; }
    });

    // ===== Pintura =====
    let paintOn=false, paintLayer=null, pctx=null, currentColor='#ff9900', erase=false, tool='bucket', drawing=false;
    function ensurePaint(){ if(!paintLayer){ paintLayer=document.createElement('canvas'); paintLayer.width=canvas.width; paintLayer.height=canvas.height; pctx=paintLayer.getContext('2d'); } }
    function getClickXY(evt){ const r=canvas.getBoundingClientRect(); const x=(evt.clientX-r.left)*(canvas.width/r.width); const y=(evt.clientY-r.top)*(canvas.height/r.height); return {x:Math.floor(x),y:Math.floor(y)}; }
    function isBarrier(i,data){
  var a = data[i+3];
  if (a < 8) return false; // transparente: no es barrera
  var r=data[i], g=data[i+1], b=data[i+2];
  // Umbral por luminancia (m√°s robusto que suma RGB)
  var y = 0.299*r + 0.587*g + 0.114*b;
  return y < 90; // l√≠nea/borde oscura => barrera
}
    function hexToRGB(hex){ const v=hex.replace('#',''); const n=parseInt(v,16); return [(n>>16)&255,(n>>8)&255,n&255]; }
    function updateCursor(){
      if(panMode){ canvas.style.cursor = draggingPan ? 'grabbing' : 'grab'; return; }
      if(!paintOn){ canvas.style.cursor='default'; return; }
      if(erase){ canvas.style.cursor='not-allowed'; } else { canvas.style.cursor='cell'; }
    }

    function floodFill(x,y){
      if(!guideData){ render(); if(!guideData) return; }
      ensurePaint();
      const w=canvas.width,h=canvas.height; const g=guideData.data;
      const mxData= lastMask ? lastMask.getContext('2d').getImageData(0,0,w,h).data : null;
      const painted=pctx.getImageData(0,0,w,h); const pd=painted.data;
      const idx=(xx,yy)=>(yy*w+xx)*4; const s=idx(x,y);
            // Si el clic cae sobre una l√≠nea, busca un p√≠xel vecino v√°lido como semilla
      if (isBarrier(s, g)){
        let found = false;
        for (let r=1; r<=2 && !found; r++){
          for (let dy=-r; dy<=r && !found; dy++){
            for (let dx=-r; dx<=r && !found; dx++){
              const nx = x+dx, ny = y+dy; if(nx<0||ny<0||nx>=w||ny>=h) continue;
              const ni = idx(nx,ny);
              if (!isBarrier(ni, g)) { x = nx; y = ny; found = true; }
            }
          }
        }
        if(!found) return;
      }

      const clickInside = !mxData ? true : (mxData[s+3]>0);
      const rgb=hexToRGB(currentColor); const seen=new Uint8Array(w*h); const q=[{x,y}];
      const cond=function(xx,yy){
        const i=idx(xx,yy);
        const notLine = !isBarrier(i,g);
        const inMask = mxData? (mxData[i+3]>0):true;
        return notLine && (clickInside ? inMask : !inMask) && !seen[yy*w+xx];
      };
      while(q.length){
        const p=q.pop(); let xi=p.x; const py=p.y;
        while(xi>=0 && cond(xi,py)) xi--; xi++;
        let up=false,down=false;
        while(xi<w && cond(xi,py)){
          const di=idx(xi,py); seen[py*w+xi]=1;
          if(erase){ pd[di]=pd[di+1]=pd[di+2]=0; pd[di+3]=0; }
          else { pd[di]=rgb[0]; pd[di+1]=rgb[1]; pd[di+2]=rgb[2]; pd[di+3]=255; }
          if(py>0){ if(cond(xi,py-1)&&!up){ q.push({x:xi,y:py-1}); up=true; } else if(!cond(xi,py-1)){ up=false; } }
          if(py<h-1){ if(cond(xi,py+1)&&!down){ q.push({x:xi,y:py+1}); down=true; } else if(!cond(xi,py+1)){ down=false; } }
          xi++;
        }
      }
      pctx.putImageData(painted,0,0); render();
    }

    // Eventos del canvas
    canvas.addEventListener('click',function(e){
      if(panMode) return;
      if(!paintOn){ // autoactivar pintar si se hace clic con Fill
        if(tool==='bucket'){ paintOn=true; paintOverlay.classList.add('show'); paintToggle.setAttribute('aria-pressed','true'); ensurePaint(); }
        else return;
      }
      if(tool==='bucket'){ const pt=getClickXY(e); floodFill(pt.x,pt.y); }
    });
    canvas.addEventListener('pointerdown', function(e){
  // Prevent page scroll when interacting
  if(e.pointerType === 'touch') e.preventDefault();
  if(panMode){
    draggingPan = true;
    panStart = { x: e.clientX, y: e.clientY, ox: tileOffsetX, oy: tileOffsetY };
    try{ canvas.setPointerCapture(e.pointerId); }catch(_){ }
    updateCursor(); return;
  }
  if(!paintOn || tool!=='brush') return;
  ensurePaint(); drawing=true; const pt=getClickXY(e);
  pctx.save(); pctx.globalCompositeOperation= erase? 'destination-out':'source-over';
  pctx.lineCap='round'; pctx.lineJoin='round'; pctx.strokeStyle=currentColor;
  pctx.lineWidth=parseInt(brushSizeEl.value||20,10); pctx.beginPath(); pctx.moveTo(pt.x,pt.y);
});
    canvas.addEventListener('pointermove', function(e){
  if(e.pointerType === 'touch') e.preventDefault();
  if(panMode && draggingPan){
    tileOffsetX = panStart.ox + (e.clientX - panStart.x);
    tileOffsetY = panStart.oy + (e.clientY - panStart.y);
    render(); return;
  }
  if(!drawing || !paintOn || tool!=='brush') return; const pt=getClickXY(e);
  pctx.lineTo(pt.x,pt.y); pctx.stroke(); render();
});
    window.addEventListener('pointerup', function(){
  if(panMode && draggingPan){ draggingPan=false; updateCursor(); }
  if(drawing){ drawing=false; pctx.closePath(); }
});
window.addEventListener('pointercancel', function(){
  if(panMode && draggingPan){ draggingPan=false; updateCursor(); }
  if(drawing){ drawing=false; try{ pctx.closePath(); }catch(_){ } }
});

    // Flechas para mover mosaico en modo mano
    document.addEventListener('keydown', function(e){
      if(!panMode) return;
      const t = e.target;
      if(t && (t.tagName==='INPUT' || t.tagName==='SELECT' || t.tagName==='TEXTAREA' || t.isContentEditable)) return;
      const step = e.shiftKey ? 40 : (e.altKey ? 2 : 10);
      let used=false;
      if(e.key==='ArrowLeft'){ tileOffsetX -= step; used=true; }
      else if(e.key==='ArrowRight'){ tileOffsetX += step; used=true; }
      else if(e.key==='ArrowUp'){ tileOffsetY -= step; used=true; }
      else if(e.key==='ArrowDown'){ tileOffsetY += step; used=true; }
      if(used){ e.preventDefault(); render(); }
    });

    // ===== Botones de UI =====
    paintToggle.addEventListener('click',function(){
      paintOn=!paintOn;
      paintToggle.setAttribute('aria-pressed',paintOn?'true':'false');
      paintOverlay.classList.toggle('show',paintOn);
      if(paintOn){
        setPanMode(false);
        ensurePaint();
        render();
      }
      updateCursor();
    });

    mosaicToggle.addEventListener('click', function(){
      mosaicVisible = !mosaicVisible;
      mosaicToggle.setAttribute('aria-pressed', mosaicVisible ? 'true' : 'false');
      mosaicToggle.title = I18N[currentLang][ mosaicVisible ? 'mosaicTitleOn' : 'mosaicTitleOff' ];
      render();
    });

    panToggle.addEventListener('click', function(){
      setPanMode(!panMode);
      if(panMode && paintOn){ paintOverlay.classList.remove('show'); }
      if(!panMode && paintOn){ paintOverlay.classList.add('show'); }
    });

    bucketBtn.addEventListener('click',function(){
      if(panMode) setPanMode(false);
      tool='bucket'; erase=false;
      bucketBtn.setAttribute('aria-pressed','true'); brushBtn.setAttribute('aria-pressed','false'); eraserBtn.setAttribute('aria-pressed','false');
      document.querySelector('#paintOverlay .palette').style.display='flex';
      if(!paintOn){ paintOn=true; paintOverlay.classList.add('show'); paintToggle.setAttribute('aria-pressed','true'); }
      ensurePaint(); render(); updateCursor();
    });
    brushBtn.addEventListener('click',function(){
      if(panMode) setPanMode(false);
      tool='brush'; erase=false;
      bucketBtn.setAttribute('aria-pressed','false'); brushBtn.setAttribute('aria-pressed','true'); eraserBtn.setAttribute('aria-pressed','false');
      document.querySelector('#paintOverlay .palette').style.display='flex';
      if(!paintOn){ paintOn=true; paintOverlay.classList.add('show'); paintToggle.setAttribute('aria-pressed','true'); }
      ensurePaint(); render(); updateCursor();
    });
    brushSizeEl && brushSizeEl.addEventListener('input', function(){ brushSizeVal.textContent = this.value + ' px'; });
    palette.addEventListener('click',function(e){ if(panMode) setPanMode(false); const btn=e.target.closest('.swatch'); if(!btn) return; currentColor=btn.getAttribute('data-c'); });
    eraserBtn.addEventListener('click',function(){ if(panMode) setPanMode(false);
      erase=!erase; tool= erase? 'brush':'bucket'; eraserBtn.setAttribute('aria-pressed', erase?'true':'false'); bucketBtn.setAttribute('aria-pressed', erase?'false':'true'); brushBtn.setAttribute('aria-pressed', erase?'true':'false'); document.querySelector('#paintOverlay .palette').style.display= erase? 'none':'flex'; updateCursor(); });
    clearPaintBtn.addEventListener('click',function(){ if(!paintLayer) return; const prev=canvas.style.cursor; canvas.style.cursor='wait'; setTimeout(function(){ canvas.style.cursor=prev; },250); pctx.clearRect(0,0,paintLayer.width,paintLayer.height); render(); });

    // ===== Reset global =====
    function resetAll(){
      // Estado
      mosaicVisible = true;
      setPanMode(false);
      draggingPan = false; panStart = null;
      tileOffsetX = 0; tileOffsetY = 0;

      // Pintura
      paintOn = false; paintOverlay.classList.remove('show'); paintToggle.setAttribute('aria-pressed','false');
      paintLayer = null; pctx = null; currentColor='#ff9900'; erase=false; tool='bucket'; drawing=false;
      bucketBtn.setAttribute('aria-pressed','true'); brushBtn.setAttribute('aria-pressed','false'); eraserBtn.setAttribute('aria-pressed','false');
      document.querySelector('#paintOverlay .palette').style.display='flex';

      // M√°scara y gu√≠a
      lastMask=null; lastBorder=null; guideData=null;

      // Selectores/controles a valores por defecto
      imgScaleEl.value=100; imgScaleVal.textContent='100%';
      tileEl.value=180; tileVal.textContent='180 px';
      borderWidthEl.value=6; borderWidthVal.textContent='6 px';
      strokeEl.value=1.8; strokeVal.textContent='1.8';
      dilateEl.value=6; dilateVal.textContent='6 px';
      blurEl.value=2; blurVal.textContent='2 px';
      edgeThrEl.value=35; edgeThrVal.textContent='35';
      thrFixedEl.value=200; thrFixedVal.textContent='200';
      ringsEl.value=10; ringsVal.textContent='10';
      spokesEl.value=20; spokesVal.textContent='20';
      styleEl.value='ellipse';
      methodEl.value='auto';
      invertSel.value='inside';
      exportScaleEl.value='1';
      formatEl.value='png';
      bgMode.value='transparent';
      applyBgModeVisual();

      // Botones
      mosaicToggle.setAttribute('aria-pressed','true');
      mosaicToggle.title = I18N[currentLang]['mosaicTitleOn'];
      panToggle.setAttribute('aria-pressed','false');
      waveBtn.setAttribute('aria-pressed','false'); creditsOn=false; creditsOverlay.classList.remove('show'); creditsOverlay.innerHTML='';

      // Canvas
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);

      render();
    }

    // ===== Eventos de UI generales =====
    fileBtn.addEventListener('click',function(){ fileInput.click(); });
    fileInput.addEventListener('change',function(){
      const f=fileInput.files&&fileInput.files[0];
      resetAll(); // restaurar TODO al cambiar de imagen
      fileName.textContent=f ? f.name : I18N[currentLang].none;
      if(f) (async()=>{ try{ infoDiv.textContent=(currentLang==='es'?'Procesando imagen‚Ä¶':'Processing image‚Ä¶'); imgEl=await loadBitmap(f); render(); infoDiv.textContent=''; }catch(e){ showErr((currentLang==='es'?'No se pudo cargar la imagen':'Could not load image'),e); } })();
    });

    // Language toggle buttons
    $('langEs').addEventListener('click', function(){ setLang('es'); });
    $('langEn').addEventListener('click', function(){ setLang('en'); });

    // Sincronizar etiquetas y re-render
    [blurEl,edgeThrEl,dilateEl,borderWidthEl,methodEl,thrFixedEl,invertSel,imgScaleEl,tileEl,strokeEl,spokesEl,ringsEl,styleEl,bgMode]
      .forEach(function(el){ el.addEventListener('input',function(){
        if(blurVal) blurVal.textContent=blurEl.value+' px';
        if(edgeThrVal) edgeThrVal.textContent=edgeThrEl.value;
        if(dilateVal) dilateVal.textContent=dilateEl.value+' px';
        if(borderWidthVal) borderWidthVal.textContent=borderWidthEl.value+' px';
        if(thrFixedVal) thrFixedVal.textContent=thrFixedEl.value;
        if(imgScaleVal) imgScaleVal.textContent=imgScaleEl.value+'%';
        if(tileVal) tileVal.textContent=tileEl.value+' px';
        if(strokeVal) strokeVal.textContent=parseFloat(strokeEl.value).toFixed(1);
        if(spokesVal) spokesVal.textContent=spokesEl.value;
        if(ringsVal) ringsVal.textContent=ringsEl.value;
        render();
      }); });

    function showErr(msg,e){ console.error(msg,e||''); infoDiv.textContent='‚ö†Ô∏è '+msg+(e?(' ‚Äî '+(e.message||e)):''); }

    function applyInitial(){
      setLang('en'); // iniciar en ingl√©s, como pediste
      render();
    }

    // Inicial
    applyInitial();
  
    // ======== MEJORA V6: Flood-Fusion + üèÆ con pan libre + export igual a vista ========
    let lanternOn = false;
    const lanternBtn = document.getElementById('lanternToggle');
    let __rafPending = false;
    function scheduleRender(){
      if(__rafPending) return;
      __rafPending = true;
      requestAnimationFrame(function(){ __rafPending=false; try{ render(); }catch(e){ console.error(e); } });
    }

    if(lanternBtn){
      lanternBtn.addEventListener('click', function(){
        lanternOn = !lanternOn;
        lanternBtn.setAttribute('aria-pressed', lanternOn ? 'true' : 'false');
        scheduleRender();
      });
    }

    // SHIFT + arrastrar siempre mueve el mosaico/mandala sin tener que activar la mano
    (function(){
      let draggingShift = false;
      let start = null;
      const stage = document.getElementById('c');
      if(!stage) return;
      stage.addEventListener('pointerdown', function(e){
        if(!e.shiftKey) return;
        e.preventDefault();
        draggingShift = true;
        start = { x:e.clientX, y:e.clientY, ox:tileOffsetX, oy:tileOffsetY };
        stage.setPointerCapture && stage.setPointerCapture(e.pointerId);
      });
      stage.addEventListener('pointermove', function(e){
        if(!draggingShift) return;
        const dx = e.clientX - start.x;
        const dy = e.clientY - start.y;
        tileOffsetX = start.ox + dx;
        tileOffsetY = start.oy + dy;
        scheduleRender();
      });
      function stop(){ draggingShift=false; start=null; }
      stage.addEventListener('pointerup', stop);
      stage.addEventListener('pointercancel', stop);
      stage.addEventListener('lostpointercapture', stop);
    })();

    // Overwrite the pattern filler: when üèÆ, draw a single tile centered but offset by tileOffsetX/Y
    (function(){
      const __orig = (typeof fillPatternWithOffset==='function') ? fillPatternWithOffset : null;
      if(!__orig) return;
      fillPatternWithOffset = function(ctxTarget, pat, W, H, tileSize){
        if(!pat){ return; }
        if(lanternOn){
          try{
            let tileCanvas = (typeof makeMandalaTile === 'function') ? makeMandalaTile(tileSize) : null;
            const ox = ((tileOffsetX % tileSize) + tileSize) % tileSize;
            const oy = ((tileOffsetY % tileSize) + tileSize) % tileSize;
            const cx = Math.round(W/2 - tileSize/2 + ox);
            const cy = Math.round(H/2 - tileSize/2 + oy);
            ctxTarget.save();
            ctxTarget.imageSmoothingEnabled = true;
            ctxTarget.imageSmoothingQuality = 'high';
            if(tileCanvas && tileCanvas.width){
              ctxTarget.drawImage(tileCanvas, cx, cy);
            } else {
              if(pat.setTransform){
                const m = new DOMMatrix(); m.translateSelf(cx, cy); pat.setTransform(m);
              } else { ctxTarget.translate(cx, cy); }
              ctxTarget.fillStyle = pat;
              ctxTarget.fillRect(0,0,tileSize,tileSize);
            }
            ctxTarget.restore();
          }catch(err){
            console.error('üèÆ draw error, fallback', err);
            return __orig(ctxTarget, pat, W, H, tileSize);
          }
        } else {
          return __orig(ctxTarget, pat, W, H, tileSize);
        }
      };
    })();

    // Flood-Fusion: barrera = uni√≥n de gu√≠a + canvas visible (mosaico incluido)
    (function(){
      const _oldFlood = floodFill;
      floodFill = function(x,y){
        if(!guideData){ render(); if(!guideData) return; }
        ensurePaint();
        const w=canvas.width,h=canvas.height;
        const g=guideData.data;
        let screen=null; try{ screen=ctx.getImageData(0,0,w,h).data; }catch(_){}
        const painted=pctx.getImageData(0,0,w,h); const pd=painted.data;
        const idx=(xx,yy)=>(yy*w+xx)*4;
        let s=idx(x,y);
        function isBar(i){
          if(g && g[i+3]>7){
            const y0 = 0.299*g[i] + 0.587*g[i+1] + 0.114*g[i+2];
            if (y0 < 140) return true;
          }
          if(screen && screen[i+3]>7){
            const y1 = 0.299*screen[i] + 0.587*screen[i+1] + 0.114*screen[i+2];
            if (y1 < 150) return true;
          }
          return false;
        }
        if (isBar(s)){
          let found=false;
          for (let r=1; r<=2 && !found; r++){
            for (let dy=-r; dy<=r && !found; dy++){
              for (let dx=-r; dx<=r && !found; dx++){
                const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=w||ny>=h) continue;
                const ni=idx(nx,ny);
                if(!isBar(ni)){ x=nx; y=ny; s=ni; found=true; }
              }
            }
          }
          if(!found) return;
        }
        const rgb = hexToRGB(currentColor);
        const seen = new Uint8Array(w*h);
        const q=[{x:x,y:y}];
        function cond(xx,yy){
          if(xx<0||yy<0||xx>=w||yy>=h) return false;
          const i=idx(xx,yy);
          return !isBar(i) && !seen[yy*w+xx];
        }
        while(q.length){
          const p=q.pop(); let xi=p.x; const py=p.y;
          while(xi>=0 && cond(xi,py)) xi--; xi++;
          let up=false,down=false;
          while(xi<w && cond(xi,py)){
            const di=idx(xi,py); seen[py*w+xi]=1;
            if(erase){ pd[di]=pd[di+1]=pd[di+2]=0; pd[di+3]=0; }
            else { pd[di]=rgb[0]; pd[di+1]=rgb[1]; pd[di+2]=rgb[2]; pd[di+3]=255; }
            if(py>0){ if(cond(xi,py-1)&&!up){ q.push({x:xi,y:py-1}); up=true; } else if(!cond(xi,py-1)){ up=false; } }
            if(py<h-1){ if(cond(xi,py+1)&&!down){ q.push({x:xi,y:py+1}); down=true; } else if(!cond(xi,py+1)){ down=false; } }
            xi++;
          }
        }
        pctx.putImageData(painted,0,0);
        scheduleRender();
      };
    })();

    // Export: asegura que captura el estado actual (incluye üèÆ y offsets)
    (function(){
      const btn=document.getElementById('download');
      if(!btn) return;
      btn.addEventListener('click', function(){
        // Render en el siguiente frame y luego deja continuar con el flujo original
        requestAnimationFrame(function(){
          try{ render(); }catch(_){}
        });
      }, {passive:true});
    })();
    // ======== /MEJORA V6 ========
})();
  </script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"23c74138fc1243dabdc3c1bec1e06b79","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
